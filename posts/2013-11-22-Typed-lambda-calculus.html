<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Piyush P Kurur|Typed lambda calculus</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="keywords" content="Type theory" />
    
    
    <meta name="generator" content="pandoc" />
    <link href="../stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <link href="../stylesheets/font-awesome/font-awesome.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <!--[if IE]>
      <link href="/stylesheets/ie.css"
            media="screen, projection"
            rel="stylesheet"
            type="text/css" />
    <![endif]-->
    <!--[if IE 7]>
        <link href="/stylesheets/font-awesome/font-awesome-ie7.css"
              rel="stylesheet"
              type="text/css" />
    <![endif]-->
  </head>
<body class="page">
<div id="root">
  <div class="header">
    <div class="title">
      Piyush P Kurur
    </div>
    <div class="navigation">
      <!-- Add your navigation menu here !-->

<div class="navigation-meta">

<h3 id="meta">Meta</h3>
<ul>
<li><a href="../"><i class="icon-home"></i> Home</a></li>
<li><a href="../contact/"><i class="icon-envelope"></i> Contact</a></li>
<li><a href="../legal/"><i class="icon-legal"></i> Legalese</a></li>
</ul>
</div>

<div class="navigation-work">
<h3 id="work">Work</h3>
<ul>
<li><a href="../research/"><i class="icon-lightbulb"></i> Research</a></li>
<li><a href="../teaching/"><i class="icon-book"></i> Teaching</a></li>
<li><a href="../software/"><i class="icon-laptop"></i> Software</a></li>
</ul>
</div>

<div class="navigation-blog">

<h3 id="blog">Blog</h3>
<ul>
<li><a href="../posts/archive/"><i class="icon-archive"></i> Archive</a></li>
<li><a href="../posts/feeds/atom.xml"><i class="icon-rss"></i> Atom</a>/<a href="../posts/feeds/rss.xml">Rss</a></li>
</ul>
</div>


    </div>
  </div>
  <div class="content">
    <span class="post-date">November 22, 2013 (Friday)</span>
<span class="post-tags"><i class="icon-tags"></i><a href="../posts/tags/Type%20theory.html">Type theory</a></span>
<div class="post">
  <h1 id="post-title">Typed lambda calculus</h1>
  <p>In this post, I briefly introduce typed lambda calculus in its simplest form and explain the type inference rules. The <a href="http://en.wikipedia.org/wiki/Curry-Howard_correspndence" title="Wikipedia: Curry-Howard correspndence">Curry-Howard isomorphism</a> appears for the first time here although of a toy logical system, namely the propositional logic with implication (⇒) as the only boolean operation.</p>
<h1 id="what-are-types">What are types ?</h1>
<p>We fix a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝒯</mi></mrow></math> of base types that can be thought of as the <em>built-in</em> types of the language. For this post, the set of types are all terms generated inductively as the follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>≔</mo><mi>t</mi><mo>∈</mo><mi>𝒯</mi><mo stretchy="false">∣</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>.</mo></mrow></math></p>
<p>The above inductive definition means that a type is either a basic type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>t</mi></mrow></math>, i.e an element of the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝒯</mi></mrow></math>, or it is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> are themselves types. There are few points that we want to clarify right away.</p>
<ol style="list-style-type: decimal">
<li><p>Consider the set of propositional logic formulas where the base set of propositions is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝒯</mi></mrow></math> and the only logical connective is the logical implies <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⇒</mo></mrow></math>. There is a one-to-one correspondence with types of our language: interpret the functional type symbol <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>→</mo></mrow></math> as the implication operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⇒</mo></mrow></math>. We will see in this post that this connection is <em>not</em> just skin deep.</p></li>
<li><p>The types in our language are defined independent of the terms in our lambda calculus. When we want more powerful types the will break. We will have to define the values and types together.</p></li>
</ol>
<h1 id="what-is-a-well-typed-expression">What is a well typed expression ?</h1>
<p>Intuitively, a typed lambda calculus is a version of lambda calculus where each expression is assigned a <em>type</em>. This type is used to ensure that function application is of the correct type, i.e. whenever an expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi></mrow></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi></mrow></math> is applied on another expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>, the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi></mrow></math> <em>should be</em> a function type from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>→</mo><mi>τ</mi><mo>′</mo></mrow></math>, for type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>′</mo></mrow></math>. This requires us to assign types to lambda calculus terms in a systematic way. Recall that a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus term is a variable, or an application or a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-abstraction and we should give systematic rules for assigning types for these three cases.</p>
<p>The base case would be to assign types for variables. There are two kinds of variables that can occur in an expression, free and bound. The bound variable gets its type from the site of binding by ensuring that the the only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-abstraction that are allowed are of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><mi>τ</mi><mo>.</mo><mi>e</mi></mrow></math>. In such a case every free occurance of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> is assumed to be having the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. For the free variables, the only way we can have types is by <em>type assumptions</em>, a set of assertions of the kind <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>τ</mi></mrow></math>. This is not unexpected: in any programming language the meaning of the program dependes on what the free variables are. Something similar is happening here: The type of an expression depends on the type of the free variables in it. Therefore, a well typed lambda calculus expression should be a combination of an expression and a typed assumption with certain restriction on functional application. We now formalise this notion by what are called <em>type inference rules</em>.</p>
<p>A <em>well typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus expression</em> is an ordered pair, written in the logical style <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math>, of (1) a type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math> together with (2) a typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> subject to the following inference rules:</p>
<p>Variable Rule (<strong>VAR</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow></mrow><mrow><mi>Γ</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>τ</mi><mo stretchy="false">}</mo><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>τ</mi></mrow></mfrac><mo>.</mo></mrow></math></p>
<p>Rule for application (<strong>APP</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>;</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>.</mo></mrow></math></p>
<p>Rule for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-abstraction (<strong>ABS</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo stretchy="false">}</mo><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>.</mo><mi>e</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>.</mo></mrow></math></p>
<p>The notation that we used for defining well typed terms is like a set of logical deduction rules. The stuff on the top of the horizontal line are <em>pre-conditions</em>, i.e. stuff which we already have derived, and the stuff in the bottom are <em>consequences</em>. i.e. stuff that can be*concluded given the pre-conditions on the top. Let us now interpret each of these rules informally:</p>
<p><strong>VAR</strong> : This rule states that with no pre-conditions we can derive the type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>τ</mi></mrow></math> provided it is already an assumption. This rule takes care of the free variables in the expression.</p>
<p><strong>APP</strong> : This is the rules that makes sure that the functions are applied to the right arguments. It makes sure of two things (1) We can form the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mi>e</mi></mrow></math> under the type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math> if and only if we have already derived that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> have types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> respectively and (2) if that happends then the resulting expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mi>e</mi></mrow></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> under <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math>.</p>
<p><strong>ABS</strong> : This rules assign types to the bound variables. This rule needs a bit of getting used to a we normally think in the other direction, i.e in the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>.</mo><mi>e</mi></mrow></math>, the occurance of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math>.</p>
<p>In all the above rules, we assume that the type assumptions that arise on the left hand side of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊢</mo></mrow></math> symbol satisfies some obvious conditions like, no variables should have two distinct type assumptions etc. The notion of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>α</mi></mrow></math>-conversion and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>β</mi></mrow></math>-reduction can be defined in a straight forward way.</p>
<p>In a typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus judgement like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math>, we can neglect any assuption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>σ</mi></mrow></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math> if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> does not occur freely in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math>. Therefore as far as type judgement of a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> is concerned, only free variables <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> are relevant. A natural question therefore is to ask for a given closed term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> in untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus, whether it is <em>well typed</em> or not, i.e. is there a way to assign a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> under the above rules of inference. to it For example, the term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi></mrow></math> can be assigned the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>→</mo><mi>τ</mi></mrow></math> for any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> (try it out) where as terms like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ω</mi><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mi>x</mi><mo stretchy="false">)</mo></mrow></math> <em>not</em> well typed. In particular all fixed point combinators are <em>not</em> well typed. As a result general recursion is <em>not</em> possible in this calculus. In fact the typed version is actually <em>strongly normalising</em> under <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>β</mi></mrow></math>-reduction which computationally means that every program here halt.</p>
<h1 id="curry-howard-isomorphism.">Curry-Howard isomorphism.</h1>
<p>Recall that any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> can be seen as a proposition over the set of basic proportion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝒯</mi></mrow></math> by interpreting the function type operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>→</mo></mrow></math> as the boolean implies operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⇒</mo></mrow></math>. Consider the three type inference rules that we discussed and replace any type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>σ</mi></mrow></math> or type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> in the rules above with just the associated proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> respectively. This gives a set of inference rules for a restricted form of propositional logic that has implies operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⇒</mo></mrow></math> as the only boolean operator. This isomorphism between type inference and logical inference rules is often called the Curry-Howard isomorphism and is one of the main ideas of type theory. The goal in the rest of the post is to give a different interpretation of typed lambda calculus so that some magic is removed out of this isomorphism.</p>
<p>Consider the type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math>. Normally we think of types as a subset of allowed values and the assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> as saying that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> is a value in the set associated with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. There is an alternate interpretation which makes the logical connection easy to make. Think of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> as a logical statement, proposition in this case. An assertion of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> is thought of as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> being the proof of the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. Alternatively, we think of the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> as the set of all proofs of the proposition associated with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> in which case our usual interpretation means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> is a proof of the proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. In this interpretation, a proof of the proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> should be treated a method to convert proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> to proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>. This then gives a valid interpretation all the rules of type inference as rules of building proofs.</p>
<p><strong>VAR</strong> : We can create a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> if we have such a proof by one of the assumption.</p>
<p><strong>APP</strong> : If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi></mrow></math> is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> then it is a function that converts proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>. If in addition, we have a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math>, we can apply <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi></mrow></math> to it and get the proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mi>e</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>.</p>
<p><strong>ABS</strong> : If assuming a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> we were able to get a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> (which can make use of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> as an axiom) of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> then the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>.</mo><mi>e</mi></mrow></math> is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> as it takes any input proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>p</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> and produces as output the proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo stretchy="false">[</mo><mi>x</mi><mo>:</mo><mo>=</mo><mi>p</mi><mo stretchy="false">]</mo></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>. Here <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo stretchy="false">[</mo><mi>x</mi><mo>:</mo><mo>=</mo><mi>p</mi><mo stretchy="false">]</mo></mrow></math> denotes replacing all free occurance of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>p</mi></mrow></math>.</p>
<p>This essentially is crux of the types as proofs view point. If we want to effectively use this logical content of the type theory, we need to look at richer and richer types and that is what we would be doing. We make some modest enriching in this post and leave the rest for future posts.</p>
<h1 id="the-operators-and-.">The operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∨</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∧</mo></mrow></math>.</h1>
<p>We would like our logic to have the conjunctions and disjunctions. At the type level we just need to add two additional type formation operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∧</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∨</mo></mrow></math>. As a result our types are now inductively defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>≔</mo><mi>t</mi><mo>∈</mo><mi>𝒯</mi><mo stretchy="false">∣</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub><mo stretchy="false">∣</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub><mo stretchy="false">∣</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>.</mo></mrow></math></p>
<p>To make proving conjunctions and disjunctions we need ways to create values, remember they are our proofs, of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> respectively. For conjunctions, we introduce the primitive <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">(</mo><mo>.</mo><mo>,</mo><mo>.</mo><mo stretchy="false">)</mo></mrow></math> that pairs up two expressions to give you a new expression. A value of Typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> can be created in two ways: by applying the <em>constructor</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">inl</mtext></mrow></math> on a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> or by applying the constructor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">inr</mtext></mrow></math> on a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>. The corresponding inference rules are:</p>
<p><strong>CONJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>.</mo></mrow></math></p>
<p><strong>DISJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">inl</mtext><mspace width="0.278em"></mspace><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>,</mo></mrow></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">inr</mtext><mspace width="0.278em"></mspace><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>.</mo></mrow></math></p>
<p>The justification of these rules from a proof theoretic point of view is that one can give a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> by giving a <em>pair</em> of proofs where the first component is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> and the second a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>. Similarly, we give a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> by giving either a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> except that we need to explicitly state which is the case by using the appropriate constructor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="normal">inl</mtext></mrow></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="normal">inr</mtext></mrow></math>.</p>
<p>For taking apart a conjunction into its components we also assume that we are given two more primitive <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="normal">fst</mtext></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="normal">snd</mtext></mrow></math> with the additional rules.</p>
<p><strong>PROJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">fst</mtext><mspace width="0.278em"></mspace><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub></mrow></mfrac><mo>,</mo></mrow></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">snd</mtext><mspace width="0.278em"></mspace><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>.</mo></mrow></math></p>
<h1 id="truth-falsity-and-negation.">Truth, falsity and negation.</h1>
<p>Suppose we want to capture truth and falsity in this logic. All we need to do is to add types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊤</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊥</mo></mrow></math> to the basic types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝒯</mi></mrow></math>. We also want <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊤</mo></mrow></math> to be proved easily. This can be achieved by enriching the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus with a single constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="normal">obvious</mtext></mrow></math> which has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊤</mo></mrow></math>. That there is no constant with type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊥</mo></mrow></math> is deliberate design choice as we do not want to prove <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊥</mo></mrow></math> in our logic.</p>
<!-- Global urls -->


<!-- My coding stuff   -->

<!-- Some websites -->

<!-- Some distros -->

<!-- Other languages  -->

<!-- Haskell packages  -->

<!-- Web stuff         -->

<!-- Haskell links     -->

<!-- Co-authors         -->

<!-- Conference/Journal links -->

</div>

<div class="post-comments">
    <div id="disqus_thread"></div>
</div>

<script type="text/javascript">
  var disqus_shortname  = 'piyushkurur';  // required: Short name.
  var disqus_url        = 'http://cse.iitk.ac.in/users/ppk/posts/2013-11-22-Typed-lambda-calculus.html';
                          // The url of this page
  var disqus_title      = 'Typed lambda calculus';      // The title of this post
  var disqus_identifier = '2013-11-22-Typed-lambda-calculus';  // The id of this post

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

  </div>
  <div id="powered-by-footer"></div>
</div>
<div id="powered-by">
  Powered by: <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
  <a href="http://compass-style.org"> Compass</a> and
  <a href="http://fontawesome.io"><i class="icon-flag"></i> Fontawesome</a>
</div>

</body>
</html>
