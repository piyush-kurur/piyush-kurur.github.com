<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="keywords" content="Type theory" />
    
    
    <link rel="prev" href="../posts/2014-01-11-Typed-lambda-calculus.html" />
    
    <meta name="generator" content="pandoc" />
    <link href="http://fonts.googleapis.com/css?family=Tangerine:700" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
    <link href="../stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <link href="../stylesheets/font-awesome/font-awesome.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <title>Piyush P Kurur|Dependent types</title>
  </head>
  <body>
    <div id="root" class="page">
  <div class="navigation">
    <!-- Add your navigation menu here !-->

<ul>
<li><a href="../" title="Home"><i class="fa fa-home"></i></a></li>
<li><a href="../posts/feeds/atom.xml"><i class="fa fa-rss"></i></a></li>
<li><a href="../contact/" title="Contact"><i class="fa fa-envelope"></i></a></li>
</ul>
<!--

[<i class="icon-legal " title="Legalese"/>](/legal/)

[<i class="icon-archive " title="Archive"/>](/posts/archive/)
-->

  </div>
  <div class="header">
    Piyush P Kurur
  </div>
  <div class="main-content">
    <span class="post-date">August 27, 2014 (Wednesday)</span>
<span class="post-tags"><i class="fa fa-tags"></i><a href="../posts/tags/Type%20theory.html">Type theory</a></span>
<div class="post">
  <h1 id="post-title">Dependent types</h1>
  <p>In the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>, we looked at simply typed lambda calculus where each term was associated with a type. As such the types of the language and terms were completely separated — we could define the types of the language independent of terms. A dependently typed language is one where the types can depend on values from a given type. For example consider the natural numbers <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>ℕ</mi></mrow></math>. In a language like Haskell, we can define them inductively. However, what if we want to capture the collection of residue classes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>ℕ</mi><mi>n</mi></msub></mrow></math> modulo a number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi><mo>:</mo><mi>ℕ</mi></mrow></math>. Ideally, we would want to distinguish the types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>ℕ</mi><mi>m</mi></msub></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>ℕ</mi><mi>n</mi></msub></mrow></math> for each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mo>≠</mo><mi>n</mi></mrow></math> — the term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow></math> should lead to a type error if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><msub><mi>ℕ</mi><mi>m</mi></msub></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>:</mo><msub><mi>ℕ</mi><mi>n</mi></msub></mrow></math>. A dependently typed language can supports construction of such types. For a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math>, a <em>type family</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi></mrow></math> on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> is a collection of types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> one for each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></math>.</p>
<p>In the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>, we saw that the type inference rules of simply typed lambda calculus gave us the rules of natural deduction for (a fragment of) propositional logic via the Curry-Howard isomorphism. To extend this to predicate logic, we would need a dependently typed lambda calculus as we explain now. Recall that we think of types as mathematical statements and elements of that type as proofs of the statements. Therefore, to capture predicates <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi></mrow></math> on a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math>, we need a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> for every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></math>, i.e. we need a <em>type family</em> on A. As before, to prove the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> should mean constructing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math>.</p>
<p>Given a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> and a predicate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi></mrow></math>, which in the type theory world becomes a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> and a type family <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi></mrow></math>, we need types that capture the logical formulae <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∃</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∀</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>. This is done through the dependent sum (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Σ</mi></mrow></math>) and the dependent product (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Π</mi></mrow></math>) types respectively.</p>
<h1 id="σ-types."><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Σ</mi></mrow></math>-types.</h1>
<p>For a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> and a type family <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi></mrow></math>, the <em>dependent sum type</em> (or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Σ</mi></mrow></math>-type) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> consists of all pairs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math>. The motivation is that proving the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∃</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> for the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> and predicate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi></mrow></math> on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> <em>constructively</em> involves constructing a witness element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></math> for which <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> is true. What more, in the constructive setting, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> being true has to be demonstrated by a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math>. Thus elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> can be thought of as proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∃</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math>. Clearly if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> is not inhabited, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∃</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> is not provable.</p>
<p>The ordinary product type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></math> (or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow></math> in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>) can be seen as the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Σ</mi></mrow></math>-type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>Σ</mo><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi></mrow></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi></mrow></math> is the type family that assigns <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi></mrow></math> to every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi></mrow></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math>. We can also define the ordinary sum type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow></math> (or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>∨</mo><mi>B</mi></mrow></math> in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>) as the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Σ</mi></mrow></math>-type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Σ</mi><mrow><mi>x</mi><mo>:</mo><mi>𝔹</mi></mrow></msub><mi>P</mi></mrow></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝔹</mi></mrow></math> is the boolean type containing two values <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="normal">True</mtext></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="normal">False</mtext></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi></mrow></math> is the <em>type family</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>i</mi><mi>f</mi><mi>x</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><mi>A</mi><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi>B</mi></mrow></math>.</p>
<p>The first component of any element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>z</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> gives an element of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math>. For types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> that do not have any inhabitants, it is impossible to construct element in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math>. This is in line with the idea that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∃</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mo>∅</mo><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> is false.</p>
<h1 id="π-types."><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Π</mi></mrow></math>-types.</h1>
<p>The <em>dependenent product</em> (or the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Π</mi></mrow></math>-type) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Π</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> consists of functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi></mrow></math> whose value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math>. The motivation from the logical side is that a proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∀</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> can be proved by giving a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi></mrow></math> that takes every element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></math> to a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math>. In agda, the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Π</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> is denoted by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math>.</p>
<p>Dependent type languages gives ways to construct functions in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Π</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></math> for any empty type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math>. For example, if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi><mo>:</mo><mo>⊥</mo><mo>→</mo><mtext mathvariant="normal">Type</mtext></mrow></math> is a type family we can create the function f in agda by using what is known as the <em>absurd pattern</em> (see line 2 below).</p>
<table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell">proof <span class="fu">:</span> (x <span class="fu">:</span> ⊥) <span class="ot">→</span> <span class="dt">P</span>(x) <span class="co">-- this is the dependent Π-type.</span>
proof ()               <span class="co">-- proof is defined using absurd pattern</span></code></pre></td></tr></table>
<p>This is in line with the idea that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∀</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mo>∅</mo><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> is true.</p>
<h1 id="the-vector-type-an-example-from-programming.">The <code>Vector</code> type: An example from programming.</h1>
<p>We now give an example of the famous vector type in agda used to captures lists of a particular length.</p>
<table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Vector</span> <span class="dt">A</span> <span class="fu">:</span> <span class="dt">Type</span> <span class="fu">:</span> ℕ <span class="ot">→</span> <span class="dt">Type</span> <span class="kw">where</span>
	[]    <span class="fu">:</span> <span class="dt">Vector</span> <span class="dt">A</span> <span class="dv">0</span>
	_<span class="ot">::</span>_  <span class="fu">:</span> {n <span class="fu">:</span> ℕ} <span class="ot">→</span> (a <span class="fu">:</span> <span class="dt">A</span>) <span class="ot">→</span> <span class="dt">Vector</span> <span class="dt">A</span> n <span class="ot">→</span> <span class="dt">Vector</span> <span class="dt">A</span> (succ n)</code></pre></td></tr></table>
<p>Having defined such a type we can define the function <code>head</code> as follows</p>
<table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell">head <span class="fu">:</span> {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Type</span>} <span class="ot">→</span> <span class="dt">Vector</span> <span class="dt">A</span> (succ n) <span class="ot">→</span> <span class="dt">A</span>
head (<span class="ot">x ::</span> _) <span class="fu">=</span> x</code></pre></td></tr></table>
<p>One of the advantages of this definition of <code>head</code> is that it can never be applied to an empty vector. This is because the input type <code>Vector A (succ n)</code> of <code>head</code> can never match with the type of the empty vector <code>Vector A 0</code> and hence will lead to a compile time error.</p>
<h1 id="type-inference-rules.">Type inference rules.</h1>
<p>We now give a sketch of the type inference rules for dependently typed lambda calculus. As before typing any term requires to “know” the type of all the free variables in it. We capture this by judgements of the kind <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi></mrow></math>. However, unlike in the simply typed case, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> might itself have variables embedded in it. So not just the free variables in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> but all free variables that occur in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> should appear in the type assumption. Thus our strategy of defining types independent of terms like in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">previous post</a> will not work; we need to define them hand in hand.</p>
<p>The type assumptions themselves should now be an ordered sequence of assumptions of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></math> with the added restriction that any assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></math> in the sequence, all the variables that appear free in the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> should themselves be defined previous assumptions in the sequence. As a result type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math> are no more sets but <em>ordered</em> sequences which we call <em>telescopes</em>. Finally, we can form expressions like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>e</mi></mrow></math> only if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> is known to be a valid type which in turn depends on the telescope that is effective at that context. The inference rules for dependently typed lambda calculus thus needs to define simultaneously what are the valid types, terms, telescopes and type judgements. This we capture via the following judgements.</p>
<ol style="list-style-type: decimal">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">term</mtext></mrow></math> which asserts that e is a valid term,</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">telescope</mtext></mrow></math> which asserts that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>Γ</mo></mrow></math> is a valid telescope,</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">type</mtext></mrow></math> which asserts that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> is a valid type and finally</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>A</mi></mrow></math> which asserts that the term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math>.</p></li>
</ol>
<p>We use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>ε</mi></mrow></math> to denote the empty telescope. Any judgement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">something</mtext></mrow></math> means that the judgement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">something</mtext></mrow></math> is valid under the telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math>.</p>
<p>We write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>ε</mi><mo>⊢</mo><mtext mathvariant="bold">something</mtext></mrow></math> as just <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊢</mo><mtext mathvariant="bold">something</mtext></mrow></math> or even <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">something</mtext></mrow></math>. To reduce a lot of boiler plate, we sometimes drop certain preconditions if it can be deduced from the other preconditions. For example, we drop the precondition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">telescope</mtext></mrow></math> if we also have a precondition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">something</mtext></mrow></math> latter on.</p>
<!--
  Besides these we have the special type $𝒰$ which we called the
  universe that stands of type of all types. Strictly speaking having
  such a type can make the logic inconsistent (Girard's paradox) but
  for simplicity we assume this.

  $$\frac{}{Γ ⊢ 𝒰\;\mathbf{type}}$$

  In all the above rules $Γ$ is any valid telescope (we have not
  defied what they are yet) and plays no important roles in the above
  rules. In fact, we can ignore $Γ$ and we have essentially just
  defined the types that we had in the previous. Dependent types will
  use these telescopes in a subtle way.

-->

<p><strong>Rules for telescopes</strong> : The first rule that we have is that an empty sequence is a valid telescope.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow></mrow><mrow><mi>ε</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">telescope</mtext></mrow></mfrac></mrow></math></p>
<p>The next inference rule says that we can add an assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></math> at the end of a valid telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math> provided it is possible to infer that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> is a type from the telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math>.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mo>Γ</mo><mspace width="0.278em"></mspace><mtext mathvariant="bold">telescope</mtext><mo>;</mo><mspace width="0.278em"></mspace><mo>Γ</mo><mo>⊢</mo><mi>A</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">type</mtext></mrow><mrow><mo>Γ</mo><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">telescope</mtext></mrow></mfrac><mi>x</mi><mo>∉</mo><mi>Γ</mi></mrow></math></p>
<p>We have slightly abused the notation in the expression of the side conditions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>∉</mo><mi>Γ</mi></mrow></math> which essentially says that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> is <em>fresh</em>, i.e. does not occur in any assumptions of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math>.</p>
<p><strong>Formation rules for terms</strong> : This essentially describes the syntax of our language.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow></mrow><mrow><mi>x</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">term</mtext></mrow></mfrac><mo>,</mo></mrow></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><msub><mi>e</mi><mn>1</mn></msub><mspace width="0.278em"></mspace><mtext mathvariant="bold">term</mtext><mo>;</mo><mspace width="0.278em"></mspace><msub><mi>e</mi><mn>2</mn></msub><mspace width="0.278em"></mspace><mtext mathvariant="bold">term</mtext></mrow><mrow><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub><mspace width="0.278em"></mspace><mtext mathvariant="bold">term</mtext></mrow></mfrac><mo>,</mo></mrow></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">telescope</mtext><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">type</mtext></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>e</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">term</mtext></mrow></mfrac></mrow></math></p>
<p>The first two are essentially expressing the lambda calculus syntax for variables and application in the form of rules of inference. The last rule, however says that the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>e</mi></mrow></math> is a valid term only if it is in the context of a telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> is a type.</p>
<p><strong>Formation rules for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Π</mi></mrow></math>-types</strong> : We have the following rules by which we can form types</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">type</mtext><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">type</mtext></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>Π</mi><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">type</mtext></mrow></mfrac></mrow></math></p>
<p>Notice that we omitted the precondition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">telescope</mtext></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">telescope</mtext></mrow></math> as mentioned before.</p>
<p><strong>Rules for type inferences</strong> : We have a single variable rule followed by the introduction/elimination rules for the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>Π</mo></mrow></math>-type.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">telescope</mtext></mrow><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>A</mi></mrow></mfrac></mrow></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><msub><mi>Π</mi><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo>/</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false">]</mo></mrow></mfrac></mrow></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>B</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>e</mi><mo stretchy="false">)</mo><mspace width="0.278em"></mspace><mo>:</mo><msub><mi>Π</mi><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi></mrow></mfrac></mrow></math></p>
<p>To incorporate the rules for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Σ</mi></mrow></math>-types, we need to introduce a dependent pairing primitive and the corresponding pairing operations. We leave this as an exercise.</p>
<!--

$$\frac{Γ ⊢ A\;\mathbf{type};\;Γ, x:A \vdash
		B\;\mathbf{type}} {Γ ⊢ Σ_{x:A} B\;\mathbf{type}}$$
-->

<h1 id="where-are-the-dependent-types">Where are the dependent types?</h1>
<p>The dependently typed language we introduced here is mostly useless in the absence of any interesting types and type families. One strategy would be to introduce each type and type family by hand giving its, formation, introduction and elimination rules. At the very least, we fix a base set of types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝒯</mi></mrow></math> and add the formation rule <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow></mrow><mrow><mi>t</mi><mspace width="0.278em"></mspace><mtext mathvariant="bold">type</mtext></mrow></mfrac><mi>t</mi><mo>∈</mo><mi>𝒯</mi><mo>.</mo></mrow></math> This will give us all the types described in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">previous post</a> (once we identify <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>Π</mo><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi></mrow></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow></math> whenever <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> is not free in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi></mrow></math>). To make dependently typed systems more useful actual systems supports construction of user defined types and type families. What these constructions are and what should be the restrictions on them has to be worked out. We defer this topic for the future.</p>
<!-- Global urls -->

<!-- Course home pages -->

<!-- My coding stuff   -->

<!-- Some websites -->

<!-- Some distros -->

<!-- Other languages  -->

<!-- Haskell packages  -->

<!-- Web stuff         -->

<!-- Haskell links     -->

<!-- Co-authors         -->

<!-- Conference/Journal links -->

</div>

<div class="post-comments">
  <div id="disqus_thread"></div>
</div>

<script type="text/javascript">
  var disqus_shortname  = 'piyushkurur';  // required: Short name.
  var disqus_url        = 'http://cse.iitk.ac.in/users/ppk/posts/2014-08-27-Dependent-Types.html';
                          // The url of this page
  var disqus_title      = 'Dependent types';      // The title of this post
  var disqus_identifier = '2014-08-27-Dependent-Types';  // The id of this post

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

  </div>
  <div id="powered-by-footer"></div>
</div>
<div id="powered-by">
  Powered by: <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
  <a href="http://compass-style.org"> Compass</a> and
  <a href="http://fontawesome.io"><i class="fa fa-flag"></i> Fontawesome</a>
</div>

  </body>
</html>
