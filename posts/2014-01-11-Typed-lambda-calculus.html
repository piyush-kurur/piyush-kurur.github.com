<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Piyush P Kurur|Typed lambda calculus</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="keywords" content="Type theory" />
    
    
    <meta name="generator" content="pandoc" />
    <link href="../stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <link href="../stylesheets/font-awesome/font-awesome.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <!--[if IE]>
      <link href="/stylesheets/ie.css"
            media="screen, projection"
            rel="stylesheet"
            type="text/css" />
    <![endif]-->
    <!--[if IE 7]>
        <link href="/stylesheets/font-awesome/font-awesome-ie7.css"
              rel="stylesheet"
              type="text/css" />
    <![endif]-->
  </head>
<body class="page">
<div id="root">
  <div class="header">
    <div class="title">
      Piyush P Kurur
    </div>
    <div class="navigation">
      <!-- Add your navigation menu here !-->

<div class="navigation-meta">

<h3 id="meta">Meta</h3>
<ul>
<li><a href="../"><i class="icon-home"></i> Home</a></li>
<li><a href="../contact/"><i class="icon-envelope"></i> Contact</a></li>
<li><a href="../legal/"><i class="icon-legal"></i> Legalese</a></li>
</ul>
</div>

<div class="navigation-work">
<h3 id="work">Work</h3>
<ul>
<li><a href="../research/"><i class="icon-lightbulb"></i> Research</a></li>
<li><a href="../teaching/"><i class="icon-book"></i> Teaching</a></li>
<li><a href="../software/"><i class="icon-laptop"></i> Software</a></li>
</ul>
</div>

<div class="navigation-blog">

<h3 id="blog">Blog</h3>
<ul>
<li><a href="../posts/archive/"><i class="icon-archive"></i> Archive</a></li>
<li><a href="../posts/feeds/atom.xml"><i class="icon-rss"></i> Atom</a>/<a href="../posts/feeds/rss.xml">Rss</a></li>
</ul>
</div>


    </div>
  </div>
  <div class="content">
    <span class="post-date">January 11, 2014 (Saturday)</span>
<span class="post-tags"><i class="icon-tags"></i><a href="../posts/tags/Type%20theory.html">Type theory</a></span>
<div class="post">
  <h1 id="post-title">Typed lambda calculus</h1>
  <h2 id="in-memory-of-sanjeev-kumar-aggarwal-skaska.">In memory of <a href="http://cse.iitk.ac.in/users/ska" title="Sanjeev Kumar Aggarwal">Sanjeev Kumar Aggarwal (ska)</a>.</h2>
<p><strong>Update</strong>: An implementation of propositional logic in agada is available on my github repository <a href="https://github.com/piyush-kurur/sample-code/blob/master/agda/Logic.agda">sample-code/agda/Logic.agda</a></p>
<p>In this post, I briefly introduce typed lambda calculus in its simplest form and explain the type inference rules. The <a href="http://en.wikipedia.org/wiki/Curry-Howard_correspndence" title="Wikipedia: Curry-Howard correspndence">Curry-Howard isomorphism</a> appears for the first time here, although only for propositional logic.</p>
<h1 id="what-are-types">What are types ?</h1>
<p>We fix a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝒯</mi></mrow></math> of base types that can be thought of as the <em>built-in</em> types of the language. For this post, the set of types are all terms generated inductively as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>≔</mo><mi>t</mi><mo>∈</mo><mi>𝒯</mi><mo stretchy="false">∣</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>.</mo></mrow></math></p>
<p>The above inductive definition means that a type is either a basic type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>t</mi></mrow></math>, i.e. an element of the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝒯</mi></mrow></math>, or it is the function type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> are themselves types. The type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> captures the type of functions whose domain is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> and range is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>. There are few points that we want to clarify right away.</p>
<ol style="list-style-type: decimal">
<li><p>Consider the set of propositional logic formulas where the base set of propositions is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝒯</mi></mrow></math> and the only logical connective is the logical implies <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⇒</mo></mrow></math>. There is a one-to-one correspondence with types of our language: interpret the functional type symbol <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>→</mo></mrow></math> as the implication operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⇒</mo></mrow></math>. We will see in this post that this connection is <em>not</em> just skin deep.</p></li>
<li><p>The types in our language are defined independent of the terms in our lambda calculus. While this is possible for the version of typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus that we define here, when we want more powerful types this will no more be possible. We will have to define the values and types together.</p></li>
</ol>
<h1 id="what-is-a-well-typed-expression">What is a well typed expression ?</h1>
<p>Intuitively, a typed lambda calculus is a version of lambda calculus where each expression is assigned a <em>type</em>. This type is used to ensure that function application is of the correct type, i.e. whenever an expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi></mrow></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi></mrow></math> is applied on another expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>, the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi></mrow></math> <em>should be</em> a function type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>→</mo><mi>τ</mi><mo>′</mo></mrow></math>, for type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>′</mo></mrow></math>. This requires us to assign types to lambda calculus terms in a systematic way. We use the notation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> to assert that the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. Recall that a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus term is a variable, or an application or a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-abstraction. Therefore, we need to give systematic rules for assigning types for these three cases.</p>
<p>The base case would be to assign types to variables in an expression. We ensure that the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-abstraction also have to assert the type of the variable it quantifies. Thus, any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-abstraction is of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><mi>τ</mi><mo>.</mo><mi>e</mi></mrow></math> and the bound variables <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> gets its type from this abstractions, i.e. every free occurrence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> is assumed to be having the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. For the free variables, the only way we can have types is by <em>type assumptions</em>, a set of assertions of the kind <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>τ</mi></mrow></math>. The type of an expression thus depends on the type of the free variables in it. Therefore, a well typed lambda calculus expression should be a combination of an expression and a set of type assumption for the free variables in it. Furthermore, they should satisfy some additional rules which we call the <em>type inference rules</em>.</p>
<p>A <em>well typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus expression</em> is an ordered pair of (1) a type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math> together with (2) a typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math>, written in the logical style <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math>, subject to the following inference rules:</p>
<p>Variable Rule (<strong>VAR</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow></mrow><mrow><mi>Γ</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>τ</mi><mo stretchy="false">}</mo><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>τ</mi></mrow></mfrac><mo>.</mo></mrow></math></p>
<p>Rule for application (<strong>APP</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>;</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>.</mo></mrow></math></p>
<p>Rule for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-abstraction (<strong>ABS</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo stretchy="false">}</mo><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>.</mo><mi>e</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>.</mo></mrow></math></p>
<p>The notation that we used for defining well typed terms is like a set of logical deduction rules. The stuff on the top of the horizontal line are <em>pre-conditions</em>, i.e. stuff which we already have derived, and the stuff in the bottom are <em>consequences</em>. i.e. stuff that can be concluded given the pre-conditions on the top. Let us now interpret each of these rules informally:</p>
<p><strong>VAR</strong> : This rule states that with no pre-conditions we can derive the type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>τ</mi></mrow></math> provided it is already an assumption. This rule takes care of the free variables in the expression.</p>
<p><strong>APP</strong> : This is the rules that makes sure that the functions are applied to the right arguments. It makes sure of two things (1) We are allowed to form the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mi>e</mi></mrow></math> under the type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math> if and only if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> have types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> respectively under the assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math> and (2) then the resulting expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mi>e</mi></mrow></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> under <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi></mrow></math>.</p>
<p><strong>ABS</strong> : This rules assign types to the bound variables. This rule needs a bit of getting used to as we normally think in the other direction, i.e. in the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>.</mo><mi>e</mi></mrow></math>, the occurrence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math>.</p>
<p>In all the above rules, we assume that the type assumptions that arise on the left hand side of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊢</mo></mrow></math> symbol satisfies some obvious conditions like, no variables should have two distinct type assumptions etc.</p>
<h1 id="curry-howard-isomorphism.">Curry-Howard isomorphism.</h1>
<p>Recall that any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> can be seen as a proposition over the set of basic proportion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝒯</mi></mrow></math> by interpreting the function type operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>→</mo></mrow></math> as the Boolean implies operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⇒</mo></mrow></math>. Consider the three type inference rules that we discussed and replace any type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>σ</mi></mrow></math> or type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> in the rules above with just the associated proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> respectively. This gives a set of inference rules for a restricted form of propositional logic that has implies operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⇒</mo></mrow></math> as the only Boolean operator. This isomorphism between type inference and logical inference rules is often called the Curry-Howard isomorphism and is one of the main ideas of type theory. The goal in the rest of the post is to give a different interpretation of typed lambda calculus so that some magic is removed out of this isomorphism.</p>
<p>Consider the type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math>. Normally, we think of types as a subset of allowed values and the assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> as saying that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> is a value in the set associated with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. There is an alternate interpretation which makes the logical connection easy to make. Think of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> as a logical statement, proposition in this case. An assertion of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> is thought of as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> being the proof of the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. Alternatively, we think of the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> as the set of all proofs of the proposition associated with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> in which case our usual interpretation means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> is a proof of the proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. In this interpretation, a proof of the proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> should be treated a method to convert proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> to proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>. This then gives a valid interpretation of all the rules of type inference as rules of building proofs.</p>
<p><strong>VAR</strong> : We can create a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> if we have such a proof by one of the assumption.</p>
<p><strong>APP</strong> : If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi></mrow></math> is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> then it is a function that converts proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>. If in addition, we have a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math>, we can apply <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi></mrow></math> to it and get the proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mi>e</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>.</p>
<p><strong>ABS</strong> : If assuming a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> we were able to get a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> (which can make use of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> as an axiom) of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> then the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>.</mo><mi>e</mi></mrow></math> is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> as it takes any input proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>p</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> and produces as output the proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo stretchy="false">[</mo><mi>x</mi><mo>:</mo><mo>=</mo><mi>p</mi><mo stretchy="false">]</mo></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>. Here <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi><mo stretchy="false">[</mo><mi>x</mi><mo>:</mo><mo>=</mo><mi>p</mi><mo stretchy="false">]</mo></mrow></math> denotes replacing all free occurrence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>p</mi></mrow></math>.</p>
<p>This essentially is the crux of the “types as proofs” view point. If we want to effectively use this logical content of type theory, we need to look at richer and richer types and that is what we would be doing. We make some modest enriching in this post and leave the rest for future posts.</p>
<h1 id="the-operators-and-.">The operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∨</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∧</mo></mrow></math>.</h1>
<p>We would like our logic to have the conjunctions and disjunctions. At the type level we just need to add two additional type formation operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∧</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∨</mo></mrow></math>. As a result our types are now inductively defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>≔</mo><mi>t</mi><mo>∈</mo><mi>𝒯</mi><mo stretchy="false">∣</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub><mo stretchy="false">∣</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub><mo stretchy="false">∣</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>.</mo></mrow></math></p>
<p>To prove conjunctions and disjunctions, we need ways to create values (remember they are our proofs) of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> respectively. For conjunctions, we introduce the primitive <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">(</mo><mo>.</mo><mo>,</mo><mo>.</mo><mo stretchy="false">)</mo></mrow></math> that pairs up two expressions to give a new expression. A value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> can be created in two ways: by applying the <em>constructor</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">inl</mtext></mrow></math> on a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> or by applying the constructor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">inr</mtext></mrow></math> on a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>. The corresponding inference rules are:</p>
<p><strong>CONJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>.</mo></mrow></math></p>
<p><strong>DISJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">inl</mtext><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>,</mo></mrow></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">inr</mtext><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>.</mo></mrow></math></p>
<p>The justification of these rules from a proof theoretic point of view is that one can give a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> by giving a <em>pair</em> of proofs where the first component is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> and the second a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math>. Similarly, we give a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> by giving either a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></math> except that we need to explicitly state which is the case by using the appropriate constructor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">inl</mtext></mrow></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">inr</mtext></mrow></math>.</p>
<p>For taking apart a conjunction into its components we also assume that we are given two more primitive <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">fst</mtext></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">snd</mtext></mrow></math> with the additional rules.</p>
<p><strong>PROJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">fst</mtext><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><msub><mi>τ</mi><mn>1</mn></msub></mrow></mfrac><mo>,</mo></mrow></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">snd</mtext><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>.</mo></mrow></math></p>
<p>Similarly, to do case by case analysis, we would need the builtin <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">either</mtext></mrow></math></p>
<p><strong>CASE</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>l</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><mi>τ</mi><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>r</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>→</mo><mi>τ</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">either</mtext><mspace width="0.278em"></mspace><mi>l</mi><mspace width="0.278em"></mspace><mi>r</mi><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>→</mo><mi>τ</mi></mrow></mfrac><mo>.</mo></mrow></math></p>
<p>We define the the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi><mo>↔</mo><mi>τ</mi></mrow></math> of logical equivalence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi></mrow></math> as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">(</mo><mi>σ</mi><mo>→</mo><mi>τ</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>τ</mi><mo>→</mo><mi>σ</mi><mo stretchy="false">)</mo></mrow></math>.</p>
<h1 id="truth-falsity-and-negation.">Truth, falsity and negation.</h1>
<p>We have a proof theoretic view of truth and falsity in this setting. Propositions are “true” if they can be proved by giving a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus expression of that type and not true otherwise. In that sense, we only have “truths” and “not truths” and every inhabited types, i.e. types for which we can construct an element with that type, is true. Explicit truth and falsity can be achieved by adding types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊤</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊥</mo></mrow></math> to the basic types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>𝒯</mi></mrow></math> and to make <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊤</mo></mrow></math> provable, we enrich the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus with a single constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">obvious</mtext></mrow></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊤</mo></mrow></math>. That there is no constants with type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊥</mo></mrow></math> is deliberate design choice as we do not want to prove <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊥</mo></mrow></math> in our logic. Once we have the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊥</mo></mrow></math>, we can define the negation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>¬</mo><mi>τ</mi></mrow></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> to be the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>→</mo><mo>⊥</mo></mrow></math>.</p>
<p>The <em>law of excluded middle</em>, LEM for short, is the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>↔</mo><mo>¬</mo><mo>¬</mo><mi>τ</mi></mrow></math> and is <em>not</em> a basic axiom of our logic. We can in fact prove one direction <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>→</mo><mo>¬</mo><mo>¬</mo><mi>τ</mi></mrow></math>: Consider the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mi>f</mi><mo>.</mo><mi>f</mi><mi>x</mi></mrow></math>. It is easy to see that we can assign to it the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>→</mo><mo stretchy="false">(</mo><mi>τ</mi><mo>→</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>→</mo><mi>σ</mi></mrow></math> for any types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. In particular, if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi></mrow></math> is the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊥</mo></mrow></math>, we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>→</mo><mo>¬</mo><mo>¬</mo><mi>τ</mi></mrow></math>. The converse however is not provable. This might be considered as a weakness of the logic because LEM is used through out mathematics. However, there is a distinct advantage here.</p>
<ol style="list-style-type: decimal">
<li><p>The proofs that we build are <em>constructive</em> and</p></li>
<li><p>If we are in dire need of the opium called LEM, we can recover it by adding a constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">lem</mtext></mrow></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>↔</mo><mo>¬</mo><mo>¬</mo><mi>τ</mi></mrow></math> the way we added the constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">obvious</mtext></mrow></math>. However, this is never done in practice when using a proof assistant like <code>coq</code> or <code>agda</code></p></li>
</ol>
<h1 id="comparison-to-untyped-λ-calculus.">Comparison to untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus.</h1>
<p>For any typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></math> we can get an untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus term, denoted by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>e</mi></mrow></math> itself, by ``erasing’’ out all types from abstractions. Is it possible to do the other way? Can we assign types to an untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus expression in a way that is consistent to the rules defined above? Doing this algorithmically is the type inference problem. For example, consider the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi></mrow></math>. Intuition tells us that this can be assigned any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>→</mo><mi>τ</mi></mrow></math> as it is the identity function. Indeed this is the case:</p>
<ol style="list-style-type: decimal">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>τ</mi><mo stretchy="false">}</mo><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>τ</mi></mrow></math> by <strong>VAR</strong></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⊢</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>τ</mi><mo>.</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>τ</mi><mo>→</mo><mi>τ</mi></mrow></math> by <strong>ABS</strong> and (1).</p></li>
</ol>
<p>It turns out that not all terms can be consistently typed, for example <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mi>x</mi></mrow></math> cannot be assigned any type (why?).</p>
<p>Recall that the computational content of untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus is captured in the notion of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>β</mi></mrow></math>-reduction. To avoid variable collision we also need <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>α</mi></mrow></math>-conversions. It is easy to see that notion of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>α</mi></mrow></math>-conversion and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>β</mi></mrow></math>-reduction can be defined in a straight forward way for typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus. What then is the difference? The typed version of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>β</mi></mrow></math>-reduction is <em>strongly normalising</em>. It turns out that term like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ω</mi><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mi>x</mi><mo stretchy="false">)</mo></mrow></math> and fixed point combinators cannot be consistently typed. As a result general recursion, and hence infinite loops, are <em>not</em> possible in this calculus.</p>
<h1 id="consistency-and-recursion">Consistency and recursion</h1>
<p>The Curry-Howard isomorphism gives us a way to define logical system out of typed lambda calculus. Enriching the basic typed lambda calculus with constants like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">obvious</mtext></mrow></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">lem</mtext></mrow></math> is like adding axioms to the logical system assoicated with the language. In any logical system, we need to worry about consistency. In classical logic, a set of axioms together with the inference rules form an <em>inconsistent</em> system if one can prove a statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> and its negation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>¬</mo><mi>τ</mi></mrow></math>. This definition is not very useful in the type theoretic setting as it is crucially dependent on negation which we want to avoid as much as possible. An alternate way to define inconsistency is to define inconsistent system as those which proves all statements. It is this definition of inconsistency that is easier to work with in the type theoretic framework. We say that a type theoretic system, i.e. the under lying typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus and its type inference rules, is <em>inconsistent</em> if <em>every</em> type in <em>inhabited</em>. This makes sense because an inhabitant of a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> is the proof of the statement (associated) to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. In this section, we want to connect consistency and the ability to do recursion. In fact, arbitrary recursion, or equivalently a uniform way to compute fixed points, is dangerous from a consistency perspective.</p>
<p>We saw that the typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus that we defined does not support fixed point combinators and therefore does not support recursion. This severely limits the kind of programs that one can write in such a language. However, we <em>do</em> know that fixed points can be implemented on a computer. Can we enrich the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>λ</mi></mrow></math>-calculus to include a fixed point combinator by force? After all, we do know how to compile it into machine code. What would happen if we just enrich the calculus with a constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">fix</mtext></mrow></math>, much like the way we included a constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">obvious</mtext></mrow></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">lem</mtext></mrow></math>. For this to workout, we would need to augment our type inference rules with the following rule for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">fix</mtext></mrow></math></p>
<p><strong>FIX</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>:</mo><mi>τ</mi><mo>→</mo><mi>τ</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mtext mathvariant="bold">fix</mtext><mspace width="0.278em"></mspace><mi>f</mi><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mi>τ</mi></mrow></mfrac><mo>.</mo></mrow></math></p>
<p>This would mean that, if we some how create a function of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo>:</mo><mi>τ</mi><mo>→</mo><mi>τ</mi></mrow></math> then we can prove <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math> using the proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">fix</mtext><mspace width="0.278em"></mspace><mi>f</mi></mrow></math>. Recall that, for any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>, the typed lambda calculus expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>=</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>τ</mi><mo>.</mo><mi>x</mi></mrow></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi><mo>→</mo><mi>τ</mi></mrow></math>. Taking its fixed point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">fix</mtext><mspace width="0.278em"></mspace><mi>I</mi></mrow></math> will give an inhabitant of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>τ</mi></mrow></math>. Therefore, adding arbitrary fixed points will make the logic inconsistent.</p>
<p>Real world programming languages like Haskell does not care about this issue as writing infinite loops are too important for a programmer. In fact, every type in Haskell has an inhabitant, namely <code>undefined</code>. What this means is that the type system of Haskell is not directly suitable as a theorem prover although we can still use it to catch many bugs at compile time.</p>
<p>Languages like agda which has to double up as a proof assistant allow certain restricted kinds of recursion by making sure that the recursion is well formed. Other than the motivation to write real world programs, some restricted form of recursion is actually necessary to capture mathematical objects like natural numbers etc. We leave these issues for future posts.</p>
<!-- Global urls -->


<!-- My coding stuff   -->

<!-- Some websites -->

<!-- Some distros -->

<!-- Other languages  -->

<!-- Haskell packages  -->

<!-- Web stuff         -->

<!-- Haskell links     -->

<!-- Co-authors         -->

<!-- Conference/Journal links -->

</div>

<div class="post-comments">
    <div id="disqus_thread"></div>
</div>

<script type="text/javascript">
  var disqus_shortname  = 'piyushkurur';  // required: Short name.
  var disqus_url        = 'http://cse.iitk.ac.in/users/ppk/posts/2014-01-11-Typed-lambda-calculus.html';
                          // The url of this page
  var disqus_title      = 'Typed lambda calculus';      // The title of this post
  var disqus_identifier = '2014-01-11-Typed-lambda-calculus';  // The id of this post

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

  </div>
  <div id="powered-by-footer"></div>
</div>
<div id="powered-by">
  Powered by: <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
  <a href="http://compass-style.org"> Compass</a> and
  <a href="http://fontawesome.io"><i class="icon-flag"></i> Fontawesome</a>
</div>

</body>
</html>
